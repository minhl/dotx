#!/usr/local/bin/python3

import os
import sys
import yaml
import pprint
import fnmatch
import argparse
from string import Template

NEWLINE = '\n'
SPACE = ' '
DOT = '.'

MODELS_DIR = 'Models'
SCHEMAS_DIR = 'Schemas'

MODEL_TEMPLATE = '''$USING

namespace $NAMESPACE
{$PREFIX
    public class $CLASSNAME
    {
        $FIELDS
    }
}
'''

def _debug(*args):
    print('DEBUG:', *args)

def error(msg):
    print('ERROR: %s' % msg)

def errorExit(msg):
    error(msg)
    exit(1)

def info(msg):
    print(msg)

def addToList(alist, item):
    if item not in alist:
        alist.append(item)

annotationLibs = {
    'DatabaseGenerated': 'System.ComponentModel.DataAnnotations.Schema',
    'Column': 'System.ComponentModel.DataAnnotations.Schema',
}
annotationCommonLib = 'System.ComponentModel.DataAnnotations'
    
def parseAnnotates(data, libs, annotates):
    for row in data:
        lib = annotationCommonLib
        for key, value in row.items():
            if value:
                annotates.append('[%s(%s)]' % (key, value))
            else:
                annotates.append('[%s]' % key)

            if key in annotationLibs:
                lib = annotationLibs[key]
        addToList(libs, lib)


class Method(object):
    def __init__(self, data, libs):
        self.name = None
        self.type = None
        self.get = None
        self.set = None
        self.annotates = []

        for key, value in data.items():
            if key == '__@__':
                parseAnnotates(value, libs, self.annotates)
            elif key == '__get__':
                self.get = value
            elif key == '__set__':
                self.set = value
            elif self.name:
                error("Invalid method config '%s'" % key)
            else:
                self.name = key
                self.type = value

    def __repr__(self):
        rs = []
        indent = NEWLINE + SPACE * 8

        if self.annotates:
            rs.append('')
            rs.extend([x for x in self.annotates])

        rs.append('public %s %s' % (self.type, self.name))
        
        indent = NEWLINE + SPACE * 12
        spaces = SPACE * 4
        rs.append('{')
        if self.get:
            rs.append(indent.join([spaces + 'get', '{', spaces + self.get, '}']))
        if self.set:
            rs.append(indent.join([spaces + 'get', '{', spaces + self.set, '}']))
        rs.append('}')

        indent = NEWLINE + SPACE * 8
        return indent.join(rs)

class Column(object):
    def __init__(self, col, libs):
        colName, colType = '', ''
        annotates = []
        for key, value in col.items():
            if key == '__@__':
                parseAnnotates(value, libs, annotates)
            elif colName:
                error("Invalid column configuration '%s'" % key)
            else:
                colName = key
                colType = value        

        collectionsLib = 'System.Collections.Generic'

        if colName != '__text__':
            if colType.startswith('list<'):
                colType = 'ICollection<%s>' % colType[5:-1]
                addToList(libs, collectionsLib)
            elif colType.startswith('enumerable<'):
                colType = 'IEnumerable<%s>' % colType[11:-1]
                addToList(libs, collectionsLib)

        self.name = colName
        self.type = colType
        self.annotates = annotates

    def __repr__(self):
        rs = []
        indent = NEWLINE + SPACE * 8

        if self.annotates:
            rs.append('')
            rs.extend([x for x in self.annotates])

        if self.name == '__text__':
            text = indent.join(self.type.split(NEWLINE))
            rs.append(NEWLINE + text)
        else:
            rs.append('public %s %s { get; set; }' % (self.type, self.name))

        return indent.join(rs)

class Model(object):
    def __init__(self, projectName, modelName, modelData):
        self.projectName = projectName
        self.modelName = modelName
        self.filePath = None
        self.classPrefix = None
        self.viewModel = False
        self.cols = []
        self.rels = []
        self.uses = []
        self.relUses = []
        self.methods = []

        self.namespace = '%s.%s' % (projectName, MODELS_DIR)
        addToList(self.uses, 'System')

        for key, value in modelData.items():
            if key == '__cols__':
                for col in value:
                    self.cols.append(Column(col, self.uses))
            elif key == '__rels__':
                for rel in value:
                    self.rels.append(Column(rel, self.relUses))
            elif key == '__methods__':
                for met in value:
                    self.methods.append(Method(met, self.uses))
            elif key == '__prefix__':
                self.classPrefix = value
            elif key == '__viewModel__':
                self.viewModel = value
            elif key == '__filePath__':
                self.filePath = value
            else:
                error("Invalid model configuration '%s'" % key)

        if self.filePath:
            self.namespace = '%s.%s' % (self.namespace, DOT.join(self.filePath.split('/')))

    def content(self):
        uses = self.uses
        if self.relUses:
            uses.extend(self.relUses)

        using = ''
        if uses:
            uses.sort()
            using = NEWLINE.join('using %s;' % x for x in uses)
        
        prefix = ''
        if self.classPrefix:
            indent = NEWLINE + SPACE * 4
            prefix = indent + indent.join(self.classPrefix.split(NEWLINE))

        indent = NEWLINE + SPACE * 8
        fields = [str(col) for col in self.cols]

        if self.rels:
            fields.append('')
            fields.extend([str(rel) for rel in self.rels])

        if self.methods:
            fields.append('')
            fields.extend([str(m) for m in self.methods])

        fields = indent.join(fields).strip()

        namespace = self.namespace
        classname = self.modelName
        return Template(MODEL_TEMPLATE).substitute(
            USING=using,
            PREFIX=prefix,
            NAMESPACE=self.namespace,
            CLASSNAME=classname,
            FIELDS=fields)

class Schema(object):
    def __init__(self, configFile):
        self.configFile = configFile
        with open(configFile) as fp:
            self.doc = yaml.load(fp)

    def __repr__(self):
        return "Schema: %s" % self.configFile

class ModelCmd(object):
    MODELS_DIR = 'Models'
    description = "Create model file"

    def __init__(self):
        parser = argparse.ArgumentParser(description=self.description)
        parser.add_argument('--schema', help='Schema configuration file')
        parser.add_argument('--only', nargs='+', help='Process only specified models')
        parser.add_argument('--overwrite', action='store_true', help='Overwrite existing file')
        parser.add_argument('--no-write', dest='noWrite', action='store_true', help="Don't create file")
        parser.add_argument('--list', action='store_true', help='List model names')
        parser.add_argument('--check', action='store_true', help='Check schema configuration')
        parser.add_argument('--dump', action='store_true', help='Dump schema configration')
        self.args = parser.parse_args(sys.argv[2:])

        cwd = os.getcwd()
        projectName = os.path.split(cwd)[-1]
        if not os.path.exists(projectName + '.csproj'):
            errorExit("No project found for '%s'" % projectName)

        self.load_schemas()

        if self.args.dump:
            pp = pprint.PrettyPrinter(indent=2)
            for schema in self.schemas:
                info(schema.configFile)
                pp.pprint(schema.doc)
            return

        if self.args.check:
            for schema in self.schemas:
                info(schema.configFile)
                info(yaml.dump(
                    schema.doc,
                    default_flow_style=False,
                    default_style='',
                    indent=2))
            return

        models = []
        args = self.args
        for schema in self.schemas:
            for modelName, modelData in schema.doc.items():
                if modelName.startswith('__'):
                    continue
                if args.only and modelName not in args.only:
                    continue
                models.append(Model(projectName, modelName, modelData))

        if self.args.list:
            names = [m.modelName for m in models]
            names.sort()
            info(NEWLINE.join(names))
            return

        if self.args.noWrite:
            return

        if not os.path.exists(MODELS_DIR):
            os.makedirs(MODELS_DIR)

        overwrite = self.args.overwrite
        for model in models:
            filePath = model.filePath
            fileName = '%s.cs' %model.modelName
            content = model.content()
            self.createFile(fileName, content, filePath, overwrite)
            
    def load_schemas(self):
        self.schemas = []
        if self.args.schema:
            self.schemas.append(Schema(self.args.schema))
            return

        files = os.listdir(SCHEMAS_DIR)
        pattern = '*.yaml'
        for entry in files:
            if fnmatch.fnmatch(entry, pattern):
                path = os.path.join(SCHEMAS_DIR, entry)
                self.schemas.append(Schema(path))

    def createFile(self, fileName, content, customPath=None, overwrite=False):
        if customPath:
            customPath = os.path.join(self.MODELS_DIR, *(customPath.split('/')))
            if not os.path.exists(customPath):
                os.makedirs(customPath)
            filePath = os.path.join(customPath, fileName)
        else:
            filePath = os.path.join(self.MODELS_DIR, fileName)

        if not os.path.exists(filePath):
            with open(filePath, 'w') as fp:
                fp.write(content)
            info('Created ' + fileName)
        elif overwrite:
            with open(filePath, 'w') as fp:
                fp.write(content)
            info('Overwrite ' + fileName)
        else:
            info('File exists ' + fileName)


class NewFileCmd(object):
    description = 'Create new file from template'

    def __init__(self):
        parser = argparse.ArgumentParser(description=self.description)
        parser.add_argument('name', help='name arg')
        args = parser.parse_args(sys.argv[2:])

        print('NewFile: %s' % args.name)


CmdList = {
    'model': ModelCmd,
    'newfile': NewFileCmd,
}

usage = '''dotx <command> [<args>]

command are:\n    %s   
''' % '\n    '.join(['%s: %s' % (k, ModelCmd.description) for k, v in CmdList.items()])


class Dotx(object):
    def __init__(self):
        parser = argparse.ArgumentParser( usage=usage)
        parser.add_argument('command', help='Subcommand to run')
        args = parser.parse_args(sys.argv[1:2])

        if args.command not in CmdList:
            print('unrecognised command')
            parser.print_help()
            exit(0)

        CmdList[args.command]()


if __name__ == '__main__':
    Dotx()
